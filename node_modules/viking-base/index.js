var crypto = require('crypto'),
    del = require('del'),
    es = require('event-stream'),
    exec = require('child_process').exec,
    util = require('util');

module.exports = {
  // What to run after node.js and Bower packages have been installed/updated
  afterUpdate: null,
  // Prune Bower packages
  bowerPrune: function() {

    console.log('Cleaning up Bower packages...');

    exec('bower prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning Bower packages';
        }

        this.bowerUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Update Bower packages
  bowerUpdate: function() {

    console.log('Updating Bower packages...');

    exec('bower install', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating Bower packages';
        }

        this.afterUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this) );
  },
  // A hash of clean task options
  cleanOpts: {
    docs: '',
    force: {
      force: true
    },
    paths: [],
    read: {
      read: false
    }
  },
  // The dev build callback
  devCallback: function() {

    this.gulp.start('build');
  },
  // Whether or not to update dependencies
  doUpdate: false,
  // Instance of gulp module. Set by gulpfile.js.
  gulp: null,
  // Called by the gulp-htmlbuild plugin
  gulpSrc: function( opts, cb ) {

    var files = es.through(),
        paths = es.through();

    paths.pipe( es.writeArray(function( err, sources ) {

      if ( cb ) {

        cb( sources );
      }

      this.gulp.src( sources, opts ).pipe( files );

    }.bind( this )));

    return es.duplex( paths, files );
  },
  // Hashes some input value
  hash: function( input ) {

    return crypto.createHash('sha1').update( input ).digest('hex');
  },
  handlebars: {
    module: require('ember-handlebars'),
    namespace: 'Ember.TEMPLATES',
    noRedeclare: true,
    wrap: 'Ember.Handlebars.template(<%= contents %>)'
  },
  // Prune node.js packages
  npmPrune: function() {

    console.log('Cleaning up node.js packages...');

    exec('npm prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning node.js packages';
        }

        this.npmUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Update node.js packages
  npmUpdate: function() {

    console.log('Updating node.js packages...');

    exec('npm install', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating node.js packages';
        }

        this.bowerPrune();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Output folders
  output: {
    compiledHbs: 'templates.js',
    css: 'css/',
    cssHash: 'style.css',
    docs: 'docs/',
    hbs: 'js/',
    js: 'js/',
    jsHash: 'app.js',
    jquery1x: 'jquery-1x/',
    jsVendor: 'js/vendor/',
    publish: 'publish/'
  },
  parseArgs: function() {

    var args = process.argv,
        i = 3,
        len = args.length,
        option = '',
        value = '';

    for ( ; i < len; i++ ) {

      option = args[ i ].toString();

      if ( option.indexOf('--') !== -1 && args[ i + 1 ] ) {

        value = args[ i + 1 ];

        this.set( option.replace('--', ''), value );

        i++;
      }
    }
  },
  // Instance of gulp-load-plugins. Set by gulpfile.js.
  plugins: null,
  /*
   * This overrides the gulp-htmlbuild preprocess JS method.
   * It allows for multi-line output in the published HTML
   * file instead of restricting it to a single line output.
   */
  preproccessJs: function( buildFn ) {

    function extractScript( line ) {

      var matched = /(\s*)<script.+src=['"]([^"']+)["']/.exec( line );

      if ( matched ) {

        return matched[2];
      }
    }
    
    return function ( block ) {

      var extractSrc = null,
          templateSrc = null;

      function templateScript( path ) {

        var i = 0,
            output = '',
            template = block.indent + '<script src="%s"></script>';

        path = Array.isArray( path ) ? path : [ path ];

        for ( ; i < path.length; i++ ) {

          output += i ? '\n' : '';
          output += util.format( template, path[i] );
        }

        return output;
      }

      extractSrc = es.mapSync( extractScript );
      templateSrc = es.mapSync( templateScript );

      block.pipe( extractSrc );
      templateSrc.pipe( block );
      
      buildFn( es.duplex( templateSrc, extractSrc ) );
    
    }.bind( this );
  },
  /*
   * This callback is supplied to the gulp-htmlbuild plugin
   * for certain build blocks like "jsvendor" and "jqueryonex"
   */
  preprocessJsVendorCb: function( block, path ) {

    var path = path || '';

    block
      .pipe( this.gulpSrc( null, function( sources ) {

        block.end( this.replaceJsSources( sources, true ) );

      }.bind( this )))
      .pipe( this.plugins.if( this.prod, this.plugins.uglify() ) )
      .pipe( this.gulp.dest( this.output.publish + this.output.jsVendor + path ) );
  },
  // Whether or not this is a production build
  prod: false,
  // The prod build callback
  prodCallback: function() {

    var timestamp = new Date().getTime();

    this.prod = true;

    this.output.cssHash = this.hash('style-' + timestamp).substr(0, 7) + '.css';
    this.output.jsHash = this.hash('app-' + timestamp).substr(0, 7) + '.js';

    this.devCallback();
  },
  /*
   * This method actually creates gulp tasks by
   * iterating over the tasks hash
   */
  registerGulpTasks: function() {

    var cb = null,
        depends = null,
        task = null,
        taskName = '';

    // Override gulp-htmlbuild's JavaScript preprocessor function
    this.plugins.htmlbuild.preprocess.js = this.preproccessJs.bind( this );

    for ( taskName in this.tasks ) {

      if ( this.tasks.hasOwnProperty( taskName ) ) {

        cb = null;
        
        task = this.tasks[ taskName ];

        depends = task.depends || null;

        if ( task.cb ) {

          cb = task.cb.bind( this );
        }

        this.gulp.task( taskName, depends, cb );
      }
    }
  },
  // Replace JavaScript output paths
  replaceJsSources: function( sources, vendor ) {

    var i = 0,
        files = [],
        outputPath = vendor ? this.output.jsVendor : this.output.js,
        pathSegments = [];

    for ( ; i < sources.length; i++ ) {

      pathSegments = sources[i].split('/');

      // Change the path to jQuery 1x
      if (pathSegments.indexOf('jquery-1x') !== -1) {

        pathSegments[ pathSegments.length - 1 ] = this.output.jquery1x + pathSegments[ pathSegments.length - 1 ];
      }

      files.push( outputPath + pathSegments[ pathSegments.length - 1 ] );
    }

    return files;
  },
  // Set a deep property
  set: function( path, value ) {

    try {

      var i = 0,
          len = 0,
          pathSegments = [],
          prop = this;

      if ( !path || typeof path !== 'string' ) {

        throw 'Path required and must be a string';
      }

      pathSegments = path.split('.');

      len = pathSegments.length;

      for ( ; i < len; i++ ) {

        // If last path segment, set value
        if ( i === len - 1 ) {

          prop[ pathSegments[ i ] ] = value;

        // If value of path segment is an object or a function
        } else if ( typeof prop[ pathSegments[ i ] ] === 'object' || typeof prop[ pathSegments[ i ] ] === 'function' ) {

          prop = prop[ pathSegments[ i ] ];

        // Something is wrong with the path
        } else {

          throw 'Invalid path: ' + path;
        }
      }

    } catch( ex ) {

      console.log( 'set(): ' + ex );
    }
  },
  setCleanOpts: function() {

    if ( !this.cleanOpts.docs ) {
      
      this.cleanOpts.docs = this.output.docs;
    }

    if ( !this.cleanOpts.paths.length ) {

      this.cleanOpts.paths = [
        this.output.js + this.output.compiledHbs,
        this.output.publish
      ];
    }
  },
  // Input sources
  sources: {
    css: [
      'bower_components/viking-base/css/**/*.css',
      'css/**/*.css'
    ],
    hbs: 'hbs/**/*.hbs',
    html: '*.html',
    js: 'js/**/*.js',
    jsDoc: [
      'js/*.js',
      'js/app/**/*.js'
    ],
    root: [
      '*.ico',
      '*.png',
      '*.txt'
    ],
    sass: 'scss/**/*.scss'
  },
  /*
   * A hash of objects that define different gulp taks. Each
   * object might have depends or cb properties that
   * represent task dependencies and callbacks, respectively.
   */
  tasks: {
    build: {
      cb: function() {

        return this.gulp.src( this.sources.html )
          .pipe( this.plugins.htmlbuild({
            // Process CSS
            css: this.plugins.htmlbuild.preprocess.css(function( block ) {

              block
                .pipe( this.gulpSrc() )
                .pipe( this.plugins.sass() )
                .pipe( this.plugins.concat( this.output.cssHash ) )
                .pipe( this.plugins.if( this.prod, this.plugins.minifyCss() ) )
                .pipe( this.gulp.dest( this.output.publish + this.output.css ) );

              block.end( this.output.css + this.output.cssHash );

            }.bind( this ) ),

            // Process JavaScript
            js: this.plugins.htmlbuild.preprocess.js(function( block ) {

              if ( !this.prod ) {

                block
                  .pipe( this.gulpSrc( null, function( sources ) {

                    block.end( this.replaceJsSources( sources ) );

                  }.bind( this ) ) )
                  .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

              } else {

                block
                  .pipe( this.gulpSrc() )
                  .pipe( this.plugins.uglify() )
                  .pipe( this.plugins.concat( this.output.jsHash ) )
                  .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

                block.end( this.output.js + this.output.jsHash );
              }

            }.bind( this ) ),

            // Process jQuery 1x
            jqueryonex: this.plugins.htmlbuild.preprocess.js( function( block ) {

              this.preprocessJsVendorCb.call( this, block, this.output.jquery1x );

            }.bind( this ) ),

            // Process vendor scripts. Set output paths.
            jsvendor: this.plugins.htmlbuild.preprocess.js( function( block ) {

              this.preprocessJsVendorCb.call( this, block );

            }.bind( this ) )
          }))
          .pipe( this.gulp.dest( this.output.publish ) );
      },
      depends: [
        'css',
        'handlebars',
        'js-doc',
        'root'
      ]
    },
    /*
     * Clean the build output. By default this means the publish
     * folder and the compiled Handlebars templates.
     */
    clean: {
      cb: function( callback ) {

        this.setCleanOpts();

        this.parseArgs();

        del( this.cleanOpts.paths, callback );
      }
    },
    // Clean the JSDoc output
    'clean-docs': {
      cb: function( callback ) {

        this.setCleanOpts();

        this.parseArgs();

        del( this.cleanOpts.docs, callback );
      }
    },
    // Copy plain old CSS files to the publish folder
    css: {
      cb: function() {

        return this.gulp.src( this.sources.css )
          .pipe( this.gulp.dest( this.output.publish + this.output.css ) );
      }
    },
    // The default gulp build
    'default': {
      depends: [
        'dev',
        'watch'
      ]
    },
    // Build dev output
    dev: {
      cb: function() {

        if ( this.doUpdate ) {

          this.afterUpdate = this.devCallback;

          this.npmPrune();

        } else {

          this.devCallback();
        }
      },
      depends: [
        'clean'
      ]
    },
    // Compile Handlebars templates
    handlebars: {
      cb: function() {

        return this.gulp.src( this.sources.hbs )
          .pipe( this.plugins.handlebars({
            handlebars: this.handlebars.module
          }))
          .pipe( this.plugins.wrap( this.handlebars.wrap ) )
          .pipe( this.plugins.declare({
            namespace: this.handlebars.namespace,
            noRedeclare: this.handlebars.noRedeclare
          }))
          .pipe( this.plugins.concat( this.output.compiledHbs ) )
          .pipe( this.gulp.dest( this.output.hbs ) )
          .pipe( this.plugins.if( this.watch, this.gulp.dest( this.output.publish + this.output.js ) ) );
      }
    },
    // Generare JSDoc documentation
    'js-doc': {
      cb: function() {

        return this.gulp.src( this.sources.jsDoc )
          .pipe( this.plugins.jsdoc( this.output.docs ) );
      },
      // Clean the docs output first
      depends: [
        'clean-docs'
      ]
    },
    // Build production output
    prod: {
      cb: function() {

        if ( this.doUpdate ) {

          this.afterUpdate = this.prodCallback;

          this.npmPrune();

        } else {

          this.prodCallback();
        }
      },
      depends: [
        'clean'
      ]
    },
    // Get root files into publish folder
    root: {
      cb: function() {
        
        return this.gulp.src( this.sources.root )
          .pipe( this.gulp.dest( this.output.publish ) );
      }
    },
    // Compile Sass
    sass: {
      cb: function() {

        return this.gulp.src( this.sources.sass )
          .pipe( this.plugins.sass() )
          .pipe( this.gulp.dest( this.output.publish + this.output.css ) );
      }
    },
    // This tells the builds that they should update dependencies.
    update: {
      cb: function() {

        this.doUpdate = true;
      }
    },
    // Watch Sass and Handlebars for changes
    watch: {
      cb: function() {

        this.watch = true;

        this.gulp.watch( this.sources.sass, this.watchDepends.sass );

        this.gulp.watch( this.sources.hbs, this.watchDepends.hbs );
      }
    }
  },
  // Whether or not gulp is watching files
  watch: false,
  /*
   * A hash of dependencies for watch tasks
   */
  watchDepends: {
    hbs: [
      'handlebars'
    ],
    sass: [
      'sass'
    ]
  }
};