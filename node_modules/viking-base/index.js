var crypto = require('crypto'),
    es = require('event-stream'),
    exec = require('child_process').exec,
    util = require('util');

module.exports = {
  // What to run after node.js and Bower packages have been installed/updated
  afterUpdate: null,
  // Prune Bower packages
  bowerPrune: function() {

    console.log('Cleaning up Bower packages...');

    exec('bower prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning Bower packages';
        }

        this.bowerUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Update Bower packages
  bowerUpdate: function() {

    console.log('Updating Bower packages...');

    exec('bower install', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating Bower packages';
        }

        this.afterUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this) );
  },
  // A hash of clean task options
  cleanOpts: {
    docs: 'docs',
    force: {
      force: true
    },
    paths: [
      'js/templates.js',
      'publish'
    ],
    read: {
      read: false
    }
  },
  // The dev build callback
  devCallback: function() {

    this.gulp.start('build');
  },
  // Whether or not to update dependencies
  doUpdate: false,
  // Instance of gulp module. Set by gulpfile.js.
  gulp: null,
  // Called by the gulp-htmlbuild plugin
  gulpSrc: function( opts, cb ) {

    var files = es.through(),
        paths = es.through();

    paths.pipe( es.writeArray(function( err, sources ) {

      if ( cb ) {

        cb( sources );
      }

      this.gulp.src( sources, opts )
        .pipe( files );

    }.bind( this )));

    return es.duplex( paths, files );
  },
  // Hashes some input value
  hash: function( input ) {

    return crypto.createHash('sha1').update( input ).digest('hex');
  },
  /* 
   * What type of Handlebars output should be compiled.
   * See the gulp-ember-handlebars plugin documentation
   * for more details: https://www.npmjs.org/package/gulp-ember-handlebars
   */
  hbsOutputType: 'browser',
  // Prune node.js packages
  npmPrune: function() {

    console.log('Cleaning up node.js packages...');

    exec('npm prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning node.js packages';
        }

        this.npmUpdate();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Update node.js packages
  npmUpdate: function() {

    console.log('Updating node.js packages...');

    exec('npm install', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating node.js packages';
        }

        this.bowerPrune();

      } catch( ex ) {

        console.error( ex );
      }

    }.bind( this ));
  },
  // Output folders
  output: {
    compiledHbs: 'templates.js',
    css: 'css/',
    cssHash: 'style.css',
    docs: 'docs/',
    hbs: 'js/',
    js: 'js/',
    jsHash: 'main.js',
    jsVendor: 'js/vendor/',
    publish: 'publish/'
  },
  // Instance of gulp-load-plugins. Set by gulpfile.js.
  plugins: null,
  /*
   * This overrides the gulp-htmlbuild preprocess JS method.
   * It allows for multi-line output in the published HTML
   * file instead of restricting it to a single line output.
   */
  preproccessJs: function( buildFn ) {

    function extractScript( line ) {

      var matched = /(\s*)<script.+src=['"]([^"']+)["']/.exec( line );

      if ( matched ) {

        return matched[2];
      }
    }
    
    return function ( block ) {

      var extractSrc = null,
          templateSrc = null;

      function templateScript( path ) {

        var i = 0,
            output = '',
            template = block.indent + '<script src="%s"></script>';

        path = Array.isArray( path ) ? path : [ path ];

        for ( ; i < path.length; i++ ) {

          output += i ? '\n' : '';
          output += util.format( template, path[i] );
        }

        return output;
      }

      extractSrc = es.mapSync( extractScript );
      templateSrc = es.mapSync( templateScript );

      block.pipe( extractSrc );
      templateSrc.pipe( block );
      
      buildFn( es.duplex( templateSrc, extractSrc ) );
    
    }.bind( this );
  },
  // Whether or not this is a production build
  prod: false,
  // The prod build callback
  prodCallback: function() {

    var timestamp = new Date().getTime();

    this.prod = true;

    this.output.cssHash = this.hash('style-' + timestamp).substr(0, 7) + '.css';
    this.output.jsHash = this.hash('main-' + timestamp).substr(0, 7) + '.js';

    this.devCallback();
  },
  /*
   * This method actually creates gulp tasks by
   * iterating over the tasks hash
   */
  registerGulpTasks: function() {

    var cb = null,
        depends = null,
        task = null,
        taskName = '';

    // Override gulp-htmlbuild's JavaScript preprocessor function
    this.plugins.htmlbuild.preprocess.js = this.preproccessJs.bind( this );

    for ( taskName in this.tasks ) {

      if ( this.tasks.hasOwnProperty( taskName ) ) {

        cb = null;
        
        task = this.tasks[ taskName ];

        depends = task.depends || null;

        if ( task.cb ) {

          cb = task.cb.bind( this );
        }

        this.gulp.task( taskName, depends, cb );
      }
    }
  },
  // Replace JavaScript output paths
  replaceJsSources: function( sources, vendor ) {

    var i = 0,
        files = [],
        outputPath = vendor ? this.output.jsVendor : this.output.js,
        pathSegments = [];

    for ( ; i < sources.length; i++ ) {

      pathSegments = sources[i].split('/');

      files.push( outputPath + pathSegments[ (pathSegments.length - 1) ] );
    }

    return files;
  },
  // Input sources
  sources: {
    css: 'css/**/*.css',
    hbs: 'hbs/**/*.hbs',
    html: '*.html',
    js: 'js/**/*.js',
    jsDoc: [
      'js/*.js',
      'js/app/**/*.js'
    ],
    root: [
      '*.ico',
      '*.png',
      '*.txt'
    ],
    sass: 'scss/**/*.scss'
  },
  /*
   * A hash of objects that define different gulp taks. Each
   * object might have depends or cb properties that
   * represent task dependencies and callbacks, respectively.
   */
  tasks: {
    build: {
      cb: function() {

        return this.gulp.src( this.sources.html )
          .pipe( this.plugins.htmlbuild({
            // Process CSS
            css: this.plugins.htmlbuild.preprocess.css(function( block ) {

              block
                .pipe( this.gulpSrc() )
                .pipe( this.plugins.sass() )
                .pipe( this.plugins.concat( this.output.cssHash ) )
                .pipe( this.plugins.if( this.prod, this.plugins.minifyCss() ) )
                .pipe( this.gulp.dest( this.output.publish + this.output.css ) );

              block.end( this.output.css + this.output.cssHash );

            }.bind( this ) ),
            // Process JavaScript
            js: this.plugins.htmlbuild.preprocess.js(function( block ) {

              if ( !this.prod ) {

                block
                  .pipe( this.gulpSrc( null, function( sources ) {

                    block.end( this.replaceJsSources( sources ) );

                  }.bind( this ) ) )
                  .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

              } else {

                block
                  .pipe( this.gulpSrc() )
                  .pipe( this.plugins.uglify() )
                  .pipe( this.plugins.concat( this.output.jsHash ) )
                  .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

                block.end( this.output.js + this.output.jsHash );
              }
            
            }.bind( this ) ),
            // Process vendor scripts. Set output paths.
            jsvendor: this.plugins.htmlbuild.preprocess.js(function( block ) {

              block
                .pipe( this.gulpSrc( null, function( sources ) {

                  block.end( this.replaceJsSources( sources, true ) );

                }.bind( this )))
                .pipe( this.plugins.if( this.prod, this.plugins.uglify() ) )
                .pipe( this.gulp.dest( this.output.publish + this.output.jsVendor ) );
            
            }.bind( this ) )
          }))
          .pipe( this.gulp.dest( this.output.publish ) );
      },
      depends: [
        'css',
        'handlebars',
        'js-doc',
        'root'
      ]
    },
    /*
     * Clean the build output. By default this means the publish
     * folder and the compiled Handlebars templates.
     */
    clean: {
      cb: function() {

        return this.gulp.src( this.cleanOpts.paths, this.cleanOpts.read )
          .pipe( this.plugins.clean( this.cleanOpts.force ) );
      }
    },
    // Clean the JSDoc output
    'clean-docs': {
      cb: function() {

        return this.gulp.src( this.cleanOpts.docs, this.cleanOpts.read )
          .pipe( this.plugins.clean( this.cleanOpts.force ) );
      }
    },
    // Copy plain old CSS files to the publish folder
    css: {
      cb: function() {

        return gulp.src( this.sources.css )
          .pipe( gulp.dest( this.output.publish + this.output.css ) );
      }
    }
    // The default gulp build
    'default': {
      depends: [
        'dev',
        'watch'
      ]
    },
    // Build dev output
    dev: {
      cb: function() {

        if ( this.doUpdate ) {

          this.afterUpdate = this.devCallback;

          this.npmPrune();

        } else {

          this.devCallback();
        }
      },
      depends: [
        'clean'
      ]
    },
    // Compile Handlebars templates
    handlebars: {
      cb: function() {

        return this.gulp.src( this.sources.hbs )
          .pipe( this.plugins.emberHandlebars({
            outputType: this.hbsOutputType
          }))
          .pipe( this.plugins.concat( this.output.compiledHbs ) )
          .pipe( this.gulp.dest( this.output.hbs ) )
          .pipe( this.plugins.if( this.watch, this.gulp.dest( this.output.publish + this.output.js ) ) );
      }
    },
    // Generare JSDoc documentation
    'js-doc': {
      cb: function() {

        return this.gulp.src( this.sources.jsDoc )
          .pipe( this.plugins.jsdoc( this.output.docs ) );
      },
      // Clean the docs output first
      depends: [
        'clean-docs'
      ]
    },
    // Build production output
    prod: {
      cb: function() {

        if ( this.doUpdate ) {

          this.afterUpdate = this.prodCallback;

          this.npmPrune();

        } else {

          this.prodCallback();
        }
      },
      depends: [
        'clean'
      ]
    },
    // Get root files into publish folder
    root: {
      cb: function() {
        
        return this.gulp.src( this.sources.root )
          .pipe( this.gulp.dest( this.output.publish ) );
      }
    },
    // Compile Sass
    sass: {
      cb: function() {

        return this.gulp.src( this.sources.sass )
          .pipe( this.plugins.sass() )
          .pipe( this.gulp.dest( this.output.publish + this.output.css ) );
      }
    },
    // This tells the builds that they should update dependencies.
    update: {
      cb: function() {

        this.doUpdate = true;
      }
    },
    // Watch Sass and Handlebars for changes
    watch: {
      cb: function() {

        this.watch = true;

        this.gulp.watch( this.sources.sass, this.watchDepends.sass );

        this.gulp.watch( this.sources.hbs, this.watchDepends.hbs );
      }
    }
  },
  // Whether or not gulp is watching files
  watch: false,
  /*
   * A hash of dependencies for watch tasks
   */
  watchDepends: {
    hbs: [
      'handlebars'
    ],
    sass: [
      'sass'
    ]
  }
};