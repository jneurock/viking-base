var checkDepends = require('check-dependencies'),
    crypto = require('crypto'),
    del = require('del'),
    es = require('event-stream'),
    exec = require('child_process').exec,
    path = require('path'),
    q = require('q'),
    rl = require('readline'),
    util = require('util');

function noop() {}

module.exports = {
  // Properties
  
  // What to run after node.js and Bower packages have been installed/updated
  afterUpdate: null,
  // Config for the check-dependencies module
  checkDependsConfig: {
    bower: {
      checkCustomPackageNames: true,
      checkGitUrls: true,
      log: noop,
      packageManager: 'bower',
      verbose: true
    },
    npm: {
      checkCustomPackageNames: true,
      checkGitUrls: true,
      log: noop,
      packageManager: 'npm',
      verbose: true
    },
    vb: {
      checkCustomPackageNames: true,
      checkGitUrls: true,
      depsDir: process.cwd(),
      log: noop,
      packageDir: 'bower_components/viking-base',
      packageManager: 'bower',
      verbose: true
    }
  },
  // A hash of clean task options
  cleanOpts: {
    docs: '',
    force: {
      force: true
    },
    paths: [],
    read: {
      read: false
    }
  },
  // Whether or not to update dependencies
  doUpdate: false,
  // Instance of gulp module. Set by gulpfile.js.
  gulp: null,
  // HTMLBars gulp plugin options
  htmlbarsOptions: {
    isHTMLBars: true,
    templateCompiler: require('../../../ember/ember-template-compiler')
  },
  // Output folders
  output: {
    compiledHbs: 'templates.js',
    css: 'css/',
    cssHash: 'style.css',
    docs: 'docs/',
    hbs: 'js/',
    js: 'js/',
    jsHash: 'app.js',
    jquery1x: 'jquery-1x/',
    jsVendor: 'js/vendor/',
    publish: 'publish/'
  },
  // Instance of gulp-load-plugins. Set by gulpfile.js.
  plugins: null,
  // Whether or not this is a production build
  prod: false,
  // Input sources
  sources: {
    css: [
      'bower_components/viking-base/css/**/*.css',
      'css/**/*.css'
    ],
    hbs: 'hbs/**/*.hbs',
    hbsFolder: 'hbs',
    html: '*.html',
    js: 'js/**/*.js',
    jsDoc: [
      'js/*.js',
      'js/app/**/*.js'
    ],
    root: [
      '*.ico',
      '*.png',
      '*.txt'
    ],
    sass: 'scss/**/*.scss'
  },
  // Whether or not gulp is watching files
  watch: false,
  /*
   * A hash of dependencies for watch tasks
   */
  watchDepends: {
    hbs: [ 'htmlbars' ],
    sass: [ 'sass' ]
  },

  // Methods

  // Prune Bower packages
  bowerPrune: function() {

    console.log('Cleaning up Bower packages...');

    exec('bower prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning Bower packages';
        }

        this.bowerUpdate();

      } catch( ex ) {

        console.error( ex );

        process.exit(1);
      }

    }.bind( this ));
  },
  // Update Bower packages
  bowerUpdate: function() {

    console.log('Updating Bower packages...');

    exec('bower install -F', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating Bower packages';
        }

        this.afterUpdate();

      } catch( ex ) {

        console.error( ex );

        process.exit(1);
      }

    }.bind( this) );
  },
  // Build callback for "dev" and "prod" builds
  buildCallback: function( cbName ) {

    try {

      // Add "Callback" to callback name passed in, if need be
      cbName = cbName.indexOf('Callback') === -1 ? cbName + 'Callback' : cbName;

      this.checkDepends.bind( this )().then(function( results ) {

        var i = 0,
            inter = null,
            len = results.length,
            prompt = false;

        for ( ; i < len; i++ ) {

          if ( !results[ i ].depsWereOk ) {

            if ( !results[ i ].install ) {

              if ( this.checkDependsConfig.autoUpdate )  {

                this.doUpdate = true;

              } else {

                prompt = true;
              }
            }

            break;
          }
        }

        if ( prompt && !this.watch ) {

          inter = rl.createInterface({
            input: process.stdin,
            output: process.stdout
          });

          inter.question('Dependency updates are needed. Would you like to update them now? (Y/n)\n', function( answer ) {

            inter.close();

            answer = answer.toLowerCase();

            if ( answer === '' || answer.charAt(0) === 'y' || answer === 'true' || answer === '1' ) {

              this.afterUpdate = this[ cbName ];

              this.npmPrune();

            } else {

              this[ cbName ]();
            }

          }.bind( this ));

        } else if ( this.doUpdate && !this.watch ) {

          this.afterUpdate = this[ cbName ];

          this.npmPrune();

        } else {

          this[ cbName ]();
        }

      }.bind( this ));

    } catch(ex) {

      console.log( 'buildCallback():' + ex );
    }
  },
  // Check npm and Bower dependencies
  checkDepends: function() {

    return q.all([
      checkDepends( this.checkDependsConfig.npm ),
      checkDepends( this.checkDependsConfig.bower ),
      checkDepends( this.checkDependsConfig.vb )
    ]);
  },
  // The dev build callback
  devCallback: function() {

    this.gulp.start('build');
  },
  // Called by the gulp-htmlbuild plugin
  gulpSrc: function( opts, cb ) {

    var files = es.through(),
        paths = es.through();

    paths.pipe( es.writeArray(function( err, sources ) {

      if ( cb ) {

        cb( sources );
      }

      this.gulp.src( sources, opts ).pipe( files );

    }.bind( this )));

    return es.duplex( paths, files );
  },
  // Hashes some input value
  hash: function( input ) {

    return crypto.createHash('sha1').update( input ).digest('hex');
  },
  // Prune node.js packages
  npmPrune: function() {

    console.log('Cleaning up node.js packages...');

    exec('npm prune', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error pruning node.js packages';
        }

        this.npmUpdate();

      } catch( ex ) {

        console.error( ex );

        process.exit(1);
      }

    }.bind( this ));
  },
  // Update node.js packages
  npmUpdate: function() {

    console.log('Updating node.js packages...');

    exec('npm install', function( err, stdout, stderr ) {

      try {

        console.log( stdout );
        console.log( stderr );

        if ( err ) {

          throw 'There was an error installing/updating node.js packages';
        }

        this.bowerPrune();

      } catch( ex ) {

        console.error( ex );

        process.exit(1);
      }

    }.bind( this ));
  },
  parseArgs: function() {

    var args = process.argv,
        i = 3,
        len = args.length,
        option = '',
        value = '';

    for ( ; i < len; i++ ) {

      option = args[ i ].toString();

      if ( option.indexOf('--') !== -1 && args[ i + 1 ] ) {

        value = args[ i + 1 ];

        this.set( option.replace('--', ''), value );

        i++;
      }
    }
  },
  // Hook for piping HTML from gulp-htmlbuild plugin into something before build
  preBuild: function() {

    // Essentially a no-op for streams
    return es.through();
  },
  // Before cleaning files, do a little setup and check for dependency issues
  preClean: function() {

    this.setCleanOpts();

    this.parseArgs();
  },
  // CSS callback for gulp-htmlbuild plugin
  preprocessCssCb: function( block ) {

    block
      .pipe( this.gulpSrc() )
      .pipe( this.plugins.sass() )
      .pipe( this.plugins.concat( this.output.cssHash ) )
      .pipe( this.plugins.if( this.prod, this.plugins.minifyCss() ) )
      .pipe( this.gulp.dest( this.output.publish + this.output.css ) );

    block.end( this.output.css + this.output.cssHash );
  },
  /*
   * This overrides the gulp-htmlbuild preprocess JS method.
   * It allows for multi-line output in the published HTML
   * file instead of restricting it to a single line output.
   */
  preproccessJs: function( buildFn ) {

    function extractScript( line ) {

      var matched = /(\s*)<script.+src=['"]([^"']+)["']/.exec( line );

      if ( matched ) {

        return matched[2];
      }
    }
    
    return function ( block ) {

      var extractSrc = null,
          templateSrc = null;

      function templateScript( path ) {

        var i = 0,
            output = '',
            template = block.indent + '<script src="%s"></script>';

        path = Array.isArray( path ) ? path : [ path ];

        for ( ; i < path.length; i++ ) {

          output += i ? '\n' : '';
          output += util.format( template, path[i] );
        }

        return output;
      }

      extractSrc = es.mapSync( extractScript );
      templateSrc = es.mapSync( templateScript );

      block.pipe( extractSrc );
      templateSrc.pipe( block );
      
      buildFn( es.duplex( templateSrc, extractSrc ) );
    
    }.bind( this );
  },
  // JavaScript callback for gulp-htmlbuild plugin
  preprocessJsCb: function( block ) {

    if ( !this.prod ) {

      block
        .pipe( this.gulpSrc( null, function( sources ) {

          block.end( this.replaceJsSources( sources ) );

        }.bind( this ) ) )
        .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

    } else {

      block
        .pipe( this.gulpSrc() )
        .pipe( this.plugins.uglify() )
        .pipe( this.plugins.concat( this.output.jsHash ) )
        .pipe( this.gulp.dest( this.output.publish + this.output.js ) );

      block.end( this.output.js + this.output.jsHash );
    }
  },
  /*
   * This callback is supplied to the gulp-htmlbuild plugin
   * for certain build blocks like "jsvendor" and "jqueryonex"
   */
  preprocessJsVendorCb: function( block, path ) {

    var path = path || '';

    block
      .pipe( this.gulpSrc( null, function( sources ) {

        block.end( this.replaceJsSources( sources, true ) );

      }.bind( this )))
      .pipe( this.plugins.if( this.prod, this.plugins.uglify() ) )
      .pipe( this.gulp.dest( this.output.publish + this.output.jsVendor + path ) );
  },
  // The prod build callback
  prodCallback: function() {

    var timestamp = new Date().getTime();

    this.prod = true;

    this.output.cssHash = this.hash('style-' + timestamp).substr(0, 7) + '.css';
    this.output.jsHash = this.hash('app-' + timestamp).substr(0, 7) + '.js';

    this.devCallback();
  },
  /*
   * This method actually creates gulp tasks by
   * iterating over the tasks hash
   */
  registerGulpTasks: function() {

    var cb = null,
        depends = null,
        task = null,
        taskName = '';

    // Override gulp-htmlbuild's JavaScript preprocessor function
    this.plugins.htmlbuild.preprocess.js = this.preproccessJs.bind( this );

    for ( taskName in this.tasks ) {

      if ( this.tasks.hasOwnProperty( taskName ) ) {

        cb = null;
        
        task = this.tasks[ taskName ];

        depends = task.depends || null;

        if ( task.cb ) {

          cb = task.cb.bind( this );
        }

        this.gulp.task( taskName, depends, cb );
      }
    }
  },
  // Replace JavaScript output paths
  replaceJsSources: function( sources, vendor ) {

    var i = 0,
        files = [],
        outputPath = vendor ? this.output.jsVendor : this.output.js,
        pathSegments = [];

    for ( ; i < sources.length; i++ ) {

      pathSegments = sources[i].split('/');

      // Change the path to jQuery 1x
      if (pathSegments.indexOf('jquery-1x') !== -1) {

        pathSegments[ pathSegments.length - 1 ] = this.output.jquery1x + pathSegments[ pathSegments.length - 1 ];
      }

      files.push( outputPath + pathSegments[ pathSegments.length - 1 ] );
    }

    return files;
  },
  // Set a deep property
  set: function( path, value ) {

    try {

      var i = 0,
          len = 0,
          pathSegments = [],
          prop = this;

      if ( !path || typeof path !== 'string' ) {

        throw 'Path required and must be a string';
      }

      pathSegments = path.split('.');

      len = pathSegments.length;

      for ( ; i < len; i++ ) {

        // If last path segment, set value
        if ( i === len - 1 ) {

          prop[ pathSegments[ i ] ] = value;

        // If value of path segment is an object or a function
        } else if ( typeof prop[ pathSegments[ i ] ] === 'object' || typeof prop[ pathSegments[ i ] ] === 'function' ) {

          prop = prop[ pathSegments[ i ] ];

        // Something is wrong with the path
        } else {

          throw 'Invalid path: ' + path;
        }
      }

    } catch( ex ) {

      console.log( 'set(): ' + ex );
    }
  },
  setCleanOpts: function() {

    if ( !this.cleanOpts.docs ) {
      
      this.cleanOpts.docs = this.output.docs;
    }

    if ( !this.cleanOpts.paths.length ) {

      this.cleanOpts.paths = [
        this.output.js + this.output.compiledHbs,
        this.output.publish
      ];
    }
  },

  // Tasks

  /*
   * A hash of objects that define different gulp taks. Each
   * object might have depends or cb properties that
   * represent task dependencies and callbacks, respectively.
   */
  tasks: {
    build: {
      cb: function() {

        return this.gulp.src( this.sources.html )
          .pipe( this.preBuild() )
          .pipe( this.plugins.htmlbuild({
            // Process CSS
            css: this.plugins.htmlbuild.preprocess.css( this.preprocessCssCb.bind( this ) ),
            // Process JavaScript
            js: this.plugins.htmlbuild.preprocess.js( this.preprocessJsCb.bind( this ) ),
            // Process jQuery 1x
            jqueryonex: this.plugins.htmlbuild.preprocess.js( function( block ) {

              this.preprocessJsVendorCb.call( this, block, this.output.jquery1x );

            }.bind( this ) ),

            // Process vendor scripts. Set output paths.
            jsvendor: this.plugins.htmlbuild.preprocess.js( function( block ) {

              this.preprocessJsVendorCb.call( this, block );

            }.bind( this ) )
          }))
          .pipe( this.gulp.dest( this.output.publish ) );
      },
      depends: [
        'css',
        'htmlbars',
        'js-doc',
        'root'
      ]
    },
    /*
     * Clean the build output. By default this means the publish
     * folder and the compiled Handlebars templates.
     */
    clean: {
      cb: function( callback ) {

        this.preClean.bind( this )();

        del( this.cleanOpts.paths, callback );
      }
    },
    // Clean the JSDoc output
    'clean-docs': {
      cb: function( callback ) {

        this.preClean.bind( this )();

        del( this.cleanOpts.docs, callback );
      }
    },
    // Copy plain old CSS files to the publish folder
    css: {
      cb: function() {

        return this.gulp.src( this.sources.css )
          .pipe( this.gulp.dest( this.output.publish + this.output.css ) );
      }
    },
    // The default gulp build
    'default': {
      depends: [
        'dev',
        'watch'
      ]
    },
    // Build dev output
    dev: {
      cb: function() {

        this.buildCallback('dev');
      },
      depends: [
        'clean'
      ]
    },
    // Compile Handlebars templates
    htmlbars: {
      cb: function() {

        return this.gulp.src( this.sources.hbs )
          .pipe( this.plugins.htmlbars( this.htmlbarsOptions ) )
          .pipe( this.plugins.tap( function( file ) {

            if ( file.isBuffer() ) {

              var content = file.contents.toString(),
                  n = path.extname( file.relative ).length,
                  fileName = n ? file.relative.slice( 0, -n ) : file.relative;

              file.contents = new Buffer( content.replace('export default', 'Ember.TEMPLATES["' + fileName.replace(path.sep, '/') + '"] =') );
            }
          }))
          .pipe( this.plugins.concat( this.output.compiledHbs ) )
          .pipe( this.gulp.dest( this.output.hbs ) )
          .pipe( this.plugins.if( this.watch, this.gulp.dest( this.output.publish + this.output.js ) ) );
      }
    },
    // Generare JSDoc documentation
    'js-doc': {
      cb: function() {

        return this.gulp.src( this.sources.jsDoc )
          .pipe( this.plugins.jsdoc( this.output.docs ) );
      },
      // Clean the docs output first
      depends: [
        'clean-docs'
      ]
    },
    // Build production output
    prod: {
      cb: function() {

        this.buildCallback('prod');
      },
      depends: [
        'clean'
      ]
    },
    // Get root files into publish folder
    root: {
      cb: function() {
        
        return this.gulp.src( this.sources.root )
          .pipe( this.gulp.dest( this.output.publish ) );
      }
    },
    // Compile Sass
    sass: {
      cb: function() {

        return this.gulp.src( this.sources.sass )
          .pipe( this.plugins.sass() )
          .pipe( this.gulp.dest( this.output.publish + this.output.css ) );
      }
    },
    // This tells the builds that they should update dependencies.
    update: {
      cb: function() {

        this.doUpdate = true;
      }
    },
    // Watch Sass and Handlebars for changes
    watch: {
      cb: function() {

        this.watch = true;

        this.gulp.watch( this.sources.sass, this.watchDepends.sass );

        this.gulp.watch( this.sources.hbs, this.watchDepends.hbs );
      }
    }
  }
};